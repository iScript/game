{"version":3,"sources":["file:///Users/ykq/Downloads/archero/assets/migrate-canvas.ts"],"names":["setChildrenLayer","node","layer","i","l","children","length","getCanvasCameraLayer","canvas","getComponent","Canvas","cameraComponent","visibility","parent","director","Director","game","Camera","customLayerMask","builtinLayerMask","on","EVENT_AFTER_SCENE_LAUNCH","roots","getScene","allCanvases","getComponentsInChildren","filter","x","allCameras","usedLayer","forEach","persistCanvas","root","isPersistRootNode","canvases","push","val","isLayerCollided","find","availableLayers","lastAvailableLayer","setParentEngine","cc","Node","prototype","setParent","value","keepWorldTransform","call"],"mappings":";;;;;AAiDA,WAASA,gBAAT,CAA2BC,IAA3B,EAAuCC,KAAvC,EAAsD;AAClD,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGH,IAAI,CAACI,QAAL,CAAcC,MAAlC,EAA0CH,CAAC,GAAGC,CAA9C,EAAiDD,CAAC,EAAlD,EAAsD;AAClDF,MAAAA,IAAI,CAACI,QAAL,CAAcF,CAAd,EAAiBD,KAAjB,GAAyBA,KAAzB;AACAF,MAAAA,gBAAgB,CAACC,IAAI,CAACI,QAAL,CAAcF,CAAd,CAAD,EAAmBD,KAAnB,CAAhB;AACH;AACJ;;AAeD,WAASK,oBAAT,CAA+BN,IAA/B,EAA2C;AACvC,QAAIC,KAAK,GAAG,IAAZ;AACA,QAAIM,MAAM,GAAGP,IAAI,CAACQ,YAAL,CAAkBC,MAAlB,CAAb;;AACA,QAAIF,MAAM,IAAIA,MAAM,CAACG,eAArB,EAAsC;AAClC,UAAIH,MAAM,CAACG,eAAP,CAAuBC,UAAvB,GAAoCJ,MAAM,CAACP,IAAP,CAAYC,KAApD,EAA2D;AACvDA,QAAAA,KAAK,GAAGM,MAAM,CAACP,IAAP,CAAYC,KAApB;AACH,OAFD,MAEO;AACHA,QAAAA,KAAK,GAAGM,MAAM,CAACG,eAAP,CAAuBC,UAAvB,GAAoC,EAAEJ,MAAM,CAACG,eAAP,CAAuBC,UAAvB,GAAoC,CAAtC,CAA5C;AACH;;AACD,aAAOV,KAAP;AACH;;AACD,QAAID,IAAI,CAACY,MAAT,EAAiB;AACbX,MAAAA,KAAK,GAAGK,oBAAoB,CAACN,IAAI,CAACY,MAAN,CAA5B;AACH;;AACD,WAAOX,KAAP;AACH;;;;;AAvE0BY,MAAAA,Q,OAAAA,Q;AAAUC,MAAAA,Q,OAAAA,Q;AAAUC,MAAAA,I,OAAAA,I;AAAgBN,MAAAA,M,OAAAA,M;AAAQO,MAAAA,M,OAAAA,M;;;;;;;AAEjEC,MAAAA,e,GAAkB,U;AAClBC,MAAAA,gB,GAAmB,U;AAEzBL,MAAAA,QAAQ,CAACM,EAAT,CAAYL,QAAQ,CAACM,wBAArB,EAA+C,YAAM;AAAA;;AACjD,YAAMC,KAAK,yBAAGR,QAAQ,CAACS,QAAT,EAAH,uDAAG,mBAAqBlB,QAAnC;AACA,YAAImB,WAAW,0BAAGV,QAAQ,CAACS,QAAT,EAAH,wDAAG,oBAAqBE,uBAArB,CAA6Cf,MAA7C,CAAlB;AACA,YAAIc,WAAW,CAAClB,MAAZ,IAAsB,CAA1B,EAA6B;AAC7BkB,QAAAA,WAAW,GAAGA,WAAW,CAACE,MAAZ,CAAmB,UAAAC,CAAC;AAAA,iBAAI,CAAC,CAACA,CAAC,CAAChB,eAAR;AAAA,SAApB,CAAd;AAEA,YAAIiB,UAAU,0BAAGd,QAAQ,CAACS,QAAT,EAAH,wDAAG,oBAAqBE,uBAArB,CAA6CR,MAA7C,CAAjB;AACA,YAAIY,SAAS,GAAG,CAAhB;AACAD,QAAAA,UAAU,CAACE,OAAX,CAAmB,UAAAH,CAAC;AAAA,iBAAIE,SAAS,IAAKF,CAAC,CAACf,UAAF,GAAeM,eAAjC;AAAA,SAApB;AAEA,YAAMa,aAAuB,GAAG,EAAhC;;AACA,aAAK,IAAI5B,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGkB,KAAK,CAAChB,MAA1B,EAAkCH,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;AAC1C,cAAM6B,IAAI,GAAGV,KAAK,CAACnB,CAAD,CAAlB;AACA,cAAI,CAACa,IAAI,CAACiB,iBAAL,CAAuBD,IAAvB,CAAL,EAAmC;AACnC,cAAME,QAAQ,GAAGF,IAAI,CAACP,uBAAL,CAA6Bf,MAA7B,CAAjB;AACA,cAAIwB,QAAQ,CAAC5B,MAAT,KAAoB,CAAxB,EAA2B;AAC3ByB,UAAAA,aAAa,CAACI,IAAd,OAAAJ,aAAa,EAASG,QAAQ,CAACR,MAAT,CAAgB,UAAAC,CAAC;AAAA,mBAAI,CAAC,CAACA,CAAC,CAAChB,eAAR;AAAA,WAAjB,CAAT,CAAb;AACH;;AAEDoB,QAAAA,aAAa,CAACD,OAAd,CAAsB,UAACM,GAAD,EAAS;AAC3B,cAAMC,eAAe,GAAGb,WAAW,CAACc,IAAZ,CAAiB,UAAAX,CAAC;AAAA,mBAAIA,CAAC,KAAKS,GAAN,IAAcT,CAAC,CAAChB,eAAF,CAAmBC,UAAnB,GAAgCwB,GAAG,CAACzB,eAAJ,CAAqBC,UAArD,GAAkEM,eAApF;AAAA,WAAlB,CAAxB;;AACA,cAAImB,eAAJ,EAAqB;AACjB,gBAAME,eAAe,GAAG,CAACV,SAAzB;AACA,gBAAMW,kBAAkB,GAAGD,eAAe,GAAG,EAAEA,eAAe,GAAG,CAApB,CAA7C;AACAH,YAAAA,GAAG,CAACzB,eAAJ,CAAqBC,UAArB,GAAkC4B,kBAAkB,GAAIJ,GAAG,CAACzB,eAAJ,CAAqBC,UAArB,GAAkCO,gBAA1F;AACAnB,YAAAA,gBAAgB,CAACoC,GAAG,CAACnC,IAAL,EAAWuC,kBAAX,CAAhB;AACAX,YAAAA,SAAS,IAAIU,eAAb;AACH;AACJ,SATD;AAUH,OA7BD;AAsCIE,MAAAA,e,GAAkBC,EAAE,CAACC,IAAH,CAAQC,SAAR,CAAkBC,S;;AAExCH,MAAAA,EAAE,CAACC,IAAH,CAAQC,SAAR,CAAkBC,SAAlB,GAA8B,UAASC,KAAT,EAAgBC,kBAAhB,EAAoC;AAC9DN,QAAAA,eAAe,CAACO,IAAhB,CAAqB,IAArB,EAA2BF,KAA3B,EAAkCC,kBAAlC;AACA,YAAI,CAACD,KAAL,EAAY,OAFkD,CAG9D;;AACA,YAAI5C,KAAK,GAAGK,oBAAoB,CAAC,IAAD,CAAhC;;AACA,YAAIL,KAAJ,EAAW;AACP,eAAKA,KAAL,GAAaA,KAAb;AACAF,UAAAA,gBAAgB,CAAC,IAAD,EAAOE,KAAP,CAAhB;AACH;AACJ,OATD","sourcesContent":["/**\n * UI 的渲染在 v3.0 变为使用 node.layer 来判断可见性，为了保证老版本项目升级后表现一致，\n * Creator 会在运行时动态分配一个未使用的 layer 给常驻节点的 UI，避免常驻节点的 UI 与场景中\n * 的其他 UI 的 layer 发生冲突，当你确定不会发生冲突时，你可以移除此脚本.\n * \n * UI rendering has changed in v3.0 to use node.layer to determine visibility. \n * To ensure consistent performance after upgrading old projects. \n * Creator will dynamically assign an unused layer to the UI node in the persist node at \n * runtime to avoid conflicts between the layer of UI in the persist node and the \n * layer of other UI in the scene. You can remove this script when you \n * are sure there is no conflict\n */\n\nimport { _decorator, Node, director, Director, game, BaseNode, Canvas, Camera } from 'cc';\n\nconst customLayerMask = 0x000fffff;\nconst builtinLayerMask = 0xfff00000;\n\ndirector.on(Director.EVENT_AFTER_SCENE_LAUNCH, () => {\n    const roots = director.getScene()?.children as BaseNode[];\n    let allCanvases = director.getScene()?.getComponentsInChildren(Canvas) as Canvas[];\n    if (allCanvases.length <= 1) return;\n    allCanvases = allCanvases.filter(x => !!x.cameraComponent);\n    \n    let allCameras = director.getScene()?.getComponentsInChildren(Camera) as Camera[];\n    let usedLayer = 0;\n    allCameras.forEach(x => usedLayer |= (x.visibility & customLayerMask));\n\n    const persistCanvas: Canvas[] = [];\n    for (let i = 0, l = roots.length; i < l; i++) {\n        const root = roots[i];\n        if (!game.isPersistRootNode(root)) continue;\n        const canvases = root.getComponentsInChildren(Canvas);\n        if (canvases.length === 0) continue;\n        persistCanvas.push(...canvases.filter(x => !!x.cameraComponent));\n    }\n\n    persistCanvas.forEach((val) => {\n        const isLayerCollided = allCanvases.find(x => x !== val && (x.cameraComponent!.visibility & val.cameraComponent!.visibility & customLayerMask));\n        if (isLayerCollided) {\n            const availableLayers = ~usedLayer;\n            const lastAvailableLayer = availableLayers & ~(availableLayers - 1);\n            val.cameraComponent!.visibility = lastAvailableLayer | (val.cameraComponent!.visibility & builtinLayerMask);\n            setChildrenLayer(val.node, lastAvailableLayer);\n            usedLayer |= availableLayers;\n        }\n    });\n});\n\nfunction setChildrenLayer (node: Node, layer: number) {\n    for (let i = 0, l = node.children.length; i < l; i++) {\n        node.children[i].layer = layer;\n        setChildrenLayer(node.children[i], layer);\n    }\n}\n\nlet setParentEngine = cc.Node.prototype.setParent;\n\ncc.Node.prototype.setParent = function(value, keepWorldTransform) {\n    setParentEngine.call(this, value, keepWorldTransform);\n    if (!value) return;\n    // find canvas\n    let layer = getCanvasCameraLayer(this);\n    if (layer) {\n        this.layer = layer;\n        setChildrenLayer(this, layer);\n    }\n}\n\nfunction getCanvasCameraLayer (node: Node) {\n    let layer = null;\n    let canvas = node.getComponent(Canvas);\n    if (canvas && canvas.cameraComponent) {\n        if (canvas.cameraComponent.visibility & canvas.node.layer) {\n            layer = canvas.node.layer;\n        } else {\n            layer = canvas.cameraComponent.visibility & ~(canvas.cameraComponent.visibility - 1);\n        }\n        return layer;\n    }\n    if (node.parent) {\n        layer = getCanvasCameraLayer(node.parent);\n    }\n    return layer;\n}"]}